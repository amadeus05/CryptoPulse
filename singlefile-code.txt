================================================================================
  PUMP SCOUT BOT - Project full code collection
  DATA: 2025-11-09 14:33:51
================================================================================


========================================================================
  FILE: src\app.ts
========================================================================

/**
 * Точка входа приложения
 * Инициализируем DB, сервисы, биндим зависимости и стартуем бота и WebSocket
 */
import { config } from './config';
import { logger } from './utils/logger';
import { StatsService } from './services/StatsService';
import { BinanceSocketService } from './services/BinanceSocketService';
import { RateLimiterService } from './services/RateLimiterService';
import { TelegramBotService } from './services/TelegramBotService';
import { SignalDetector } from './services/SignalDetector';

async function main() {
  logger.info('Starting Crypto Watch Bot');

  // Инициализация DB (singleton в файле database.ts уже выполнит миграцию)
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  await import('./db/database');

  // Сервисы
  const stats = new StatsService();
  const telegram = new TelegramBotService();
  const rateLimiter = new RateLimiterService(60);
  const detector = new SignalDetector(stats, rateLimiter, telegram, config.CHECK_INTERVAL_SEC);

  // Binance WS
  const binance = new BinanceSocketService(stats, config.BINANCE_WS_URL);

  // Стартуем
  telegram.start();
  binance.start();
  detector.start();

  process.on('uncaughtException', (err) => {
    logger.error({ err }, 'uncaughtException');
    process.exit(1);
  });

  process.on('unhandledRejection', (reason) => {
    logger.error({ reason }, 'unhandledRejection');
  });
}

main().catch((err) => {
  logger.error({ err }, 'Failed to start app');
  process.exit(1);
});


========================================================================
  FILE: src\config.ts
========================================================================

import dotenv from 'dotenv';
dotenv.config();

export const config = {
  TELEGRAM_TOKEN: process.env.TELEGRAM_TOKEN || '',
  BINANCE_WS_URL: process.env.BINANCE_WS_URL || 'wss://stream.binance.com:9443/ws/!ticker@arr',
  DB_PATH: process.env.DB_PATH || './data/bot.db',
  CHECK_INTERVAL_SEC: Number(process.env.CHECK_INTERVAL_SEC || 10),
};


========================================================================
  FILE: src\db\database.ts
========================================================================

import Database from 'better-sqlite3';
import fs from 'fs';
import path from 'path';
import { config } from '../config';
import { logger } from '../utils/logger';

const MIGRATION_PATH = path.join(process.cwd(), 'src', 'db', 'migrations', 'init.sql');

export class DB {
  public db: Database.Database;

  constructor(private dbPath: string = config.DB_PATH) {
    const dir = path.dirname(dbPath);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });

    this.db = new Database(dbPath);
    this.db.pragma('journal_mode = WAL');
    this.init();
  }

  private init() {
    try {
      const sql = fs.readFileSync(MIGRATION_PATH, 'utf8');
      this.db.exec(sql);
      logger.info('DB initialized & migrations executed');
    } catch (err) {
      logger.error({ err }, 'DB migration failed');
      throw err;
    }
  }
}

export const db = new DB().db;


========================================================================
  FILE: src\db\migrations\init.ts
========================================================================

import fs from 'fs';
import path from 'path';
import Database from 'better-sqlite3';
import { config } from '../../config';

const MIGRATION_PATH = path.join(process.cwd(), 'src', 'db', 'migrations', 'init.sql');

function run() {
  const dbPath = config.DB_PATH || './data/bot.db';
  const dir = path.dirname(dbPath);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });

  const db = new Database(dbPath);
  db.pragma('journal_mode = WAL');
  const sql = fs.readFileSync(MIGRATION_PATH, 'utf8');
  db.exec(sql);
  console.log('Migrations executed');
  db.close();
}

run();


========================================================================
  FILE: src\db\repositories\BaseRepository.ts
========================================================================

import { db } from '../database';

export abstract class BaseRepository {
  protected db = db;
}


========================================================================
  FILE: src\db\repositories\CoinRepository.ts
========================================================================

import { BaseRepository } from './BaseRepository';

interface CoinDTO {
  id?: number;
  symbol: string;
  base_asset?: string;
  quote_asset?: string;
}

export class CoinRepository extends BaseRepository {
  createIfNotExists(symbol: string, base?: string, quote?: string): void {
    const stmt = this.db.prepare(`
      INSERT OR IGNORE INTO coins(symbol, base_asset, quote_asset)
      VALUES(?, ?, ?)
    `);
    stmt.run(symbol, base ?? null, quote ?? null);
  }

  listAll(): CoinDTO[] {
    return this.db.prepare(`SELECT * FROM coins`).all() as CoinDTO[];
  }
}


========================================================================
  FILE: src\db\repositories\SignalRepository.ts
========================================================================

import { BaseRepository } from './BaseRepository';
import { SignalDTO } from '../../dto/SignalDTO';

export class SignalRepository extends BaseRepository {
  create(signal: SignalDTO): SignalDTO {
    const stmt = this.db.prepare(`
      INSERT INTO signals(user_id, symbol, direction, percent, base_price, current_price, detected_at, sent)
      VALUES(?, ?, ?, ?, ?, ?, ?, ?)
    `);
    const now = Math.floor(Date.now() / 1000);
    const info = stmt.run(
      signal.user_id,
      signal.symbol,
      signal.direction,
      signal.percent,
      signal.base_price,
      signal.current_price,
      now,
      signal.sent ? 1 : 0
    );
    return this.db
      .prepare(`SELECT * FROM signals WHERE id = ?`)
      .get(info.lastInsertRowid) as SignalDTO;
  }

  lastSignalFor(userId: number, symbol: string, direction: string, percent: number): SignalDTO | undefined {
    return this.db
      .prepare(`
        SELECT * FROM signals WHERE user_id = ? AND symbol = ? AND direction = ? AND percent = ?
        ORDER BY detected_at DESC LIMIT 1
      `)
      .get(userId, symbol, direction, percent) as SignalDTO;
  }

  markSent(id: number): void {
    this.db.prepare(`UPDATE signals SET sent = 1 WHERE id = ?`).run(id);
  }
}


========================================================================
  FILE: src\db\repositories\StatsRepository.ts
========================================================================

import { BaseRepository } from './BaseRepository';
import { MinuteStatDTO } from '../../dto/MinuteStatDTO';

export interface MinuteStatRow {
  open?: number;
  high?: number;
  low?: number;
  volume?: number;
  ticks_count?: number;
}

export class StatsRepository extends BaseRepository {
  upsertMinuteStat(stat: MinuteStatDTO): void {
    const stmt = this.db.prepare(`
      INSERT INTO minute_stats(symbol, minute_start, open, high, low, close, volume, ticks_count)
      VALUES(@symbol,@minuteStart,@open,@high,@low,@close,@volume,@ticksCount)
      ON CONFLICT(symbol, minute_start) DO UPDATE SET
        high = excluded.high,
        low = excluded.low,
        close = excluded.close,
        volume = excluded.volume,
        ticks_count = excluded.ticks_count
    `);
    stmt.run({
      symbol: stat.symbol,
      minuteStart: stat.minute_start,
      open: stat.open,
      high: stat.high,
      low: stat.low,
      close: stat.close,
      volume: stat.volume,
      ticksCount: stat.ticks_count,
    });
  }

  getMinuteClose(symbol: string, minuteStart: number): { close: number } | undefined {
    return this.db
      .prepare(`SELECT close FROM minute_stats WHERE symbol = ? AND minute_start = ?`)
      .get(symbol, minuteStart) as { close: number } | undefined;
  }

  getLastClose(symbol: string): { close: number } | undefined {
    return this.db
      .prepare(`SELECT close FROM minute_stats WHERE symbol = ? ORDER BY minute_start DESC LIMIT 1`)
      .get(symbol) as { close: number } | undefined;
  }

  // Получить частичную свечу
  getMinuteStat(symbol: string, minuteStart: number): MinuteStatRow | undefined {
    return this.db
      .prepare(`SELECT open, high, low, volume, ticks_count FROM minute_stats WHERE symbol = ? AND minute_start = ?`)
      .get(symbol, minuteStart) as MinuteStatRow | undefined;
  }

  // НОВЫЙ МЕТОД: Проверить существование
  exists(symbol: string, minuteStart: number): boolean {
    const row = this.db
      .prepare(`SELECT 1 FROM minute_stats WHERE symbol = ? AND minute_start = ?`)
      .get(symbol, minuteStart);
    return !!row;
  }

  getCloseAt(symbol: string, minuteStart: number): number | undefined {
    const row = this.db
      .prepare(`SELECT close FROM minute_stats WHERE symbol = ? AND minute_start = ?`)
      .get(symbol, minuteStart) as { close: number } | undefined;
    return row?.close;
  }

  getLastCloseBefore(symbol: string, beforeMinuteStart: number): number | undefined {
    const row = this.db
      .prepare(`
        SELECT close FROM minute_stats 
        WHERE symbol = ? AND minute_start <= ? 
        ORDER BY minute_start DESC LIMIT 1
      `)
      .get(symbol, beforeMinuteStart) as { close: number } | undefined;
    return row?.close;
  }
}


========================================================================
  FILE: src\db\repositories\TickRepository.ts
========================================================================

import { BaseRepository } from './BaseRepository';

interface TickDTO {
  id?: number;
  symbol: string;
  price: number;
  event_ts: number;
}

export class TickRepository extends BaseRepository {
  insertTick(symbol: string, price: number, eventTs: number): void {
    const stmt = this.db.prepare(`
      INSERT INTO ticks(symbol, price, event_ts) VALUES(?, ?, ?)
    `);
    stmt.run(symbol, price, eventTs);
  }

  getOldestTickBefore(symbol: string, beforeTs: number): TickDTO | undefined {
    return this.db
      .prepare(`
        SELECT * FROM ticks WHERE symbol = ? AND event_ts <= ? ORDER BY event_ts DESC LIMIT 1
      `)
      .get(symbol, beforeTs) as TickDTO | undefined;
  }

  getLastTick(symbol: string): TickDTO | undefined {
    return this.db
      .prepare(`SELECT * FROM ticks WHERE symbol = ? ORDER BY event_ts DESC LIMIT 1`)
      .get(symbol) as TickDTO | undefined;
  }

  deleteOlderThan(beforeTs: number): void {
    const stmt = this.db.prepare(`DELETE FROM ticks WHERE event_ts < ?`);
    stmt.run(beforeTs);
  }
}


========================================================================
  FILE: src\db\repositories\UserRepository.ts
========================================================================

import { BaseRepository } from './BaseRepository';
import { UserDTO } from '../../dto/UserDTO';

export class UserRepository extends BaseRepository {
  findOrCreate(telegramId: string, username?: string): UserDTO {
    const select = this.db.prepare(`SELECT * FROM users WHERE telegram_id = ?`).get(telegramId);
    if (select) return select as UserDTO;

    const insert = this.db.prepare(`INSERT INTO users(telegram_id, username) VALUES(?, ?)`);
    const info = insert.run(telegramId, username || null);
    return this.db
      .prepare(`SELECT * FROM users WHERE id = ?`)
      .get(info.lastInsertRowid) as UserDTO;
  }

  getByTelegramId(telegramId: string): UserDTO | undefined {
    return this.db
      .prepare(`SELECT * FROM users WHERE telegram_id = ?`)
      .get(telegramId) as UserDTO;
  }

  getById(id: number): UserDTO | undefined {
    return this.db
      .prepare(`SELECT * FROM users WHERE id = ?`)
      .get(id) as UserDTO;
  }
}


========================================================================
  FILE: src\db\repositories\UserSettingsRepository.ts
========================================================================

import { BaseRepository } from './BaseRepository';
import { UserSettingDTO } from '../../dto/UserSettingDTO';

export class UserSettingsRepository extends BaseRepository {
  add(setting: UserSettingDTO): UserSettingDTO | null {
    const stmt = this.db.prepare(`
      INSERT OR IGNORE INTO user_settings(user_id, symbol, direction, percent, enabled, interval_min )
      VALUES(?, ?, ?, ?, ?, ?)
    `);
    const info = stmt.run(
      setting.user_id,
      setting.symbol,
      setting.direction,
      setting.percent,
      setting.enabled ? 1 : 0,
      setting.interval_min  ?? 20
    );
    if (info.changes) {
      return this.db
        .prepare(`SELECT * FROM user_settings WHERE id = ?`)
        .get(info.lastInsertRowid) as UserSettingDTO;
    }
    return null;
  }

  listActive(): UserSettingDTO[] {
    return this.db
      .prepare(`SELECT * FROM user_settings WHERE enabled = 1`)
      .all() as UserSettingDTO[];
  }

  listByUser(userId: number): UserSettingDTO[] {
    return this.db
      .prepare(`SELECT * FROM user_settings WHERE user_id = ?`)
      .all(userId) as UserSettingDTO[];
  }

  remove(id: number): void {
    this.db.prepare(`DELETE FROM user_settings WHERE id = ?`).run(id);
  }

  toggle(id: number): void {
    this.db.prepare(`
      UPDATE user_settings SET enabled = CASE WHEN enabled = 1 THEN 0 ELSE 1 END WHERE id = ?
    `).run(id);
  }

  getById(id: number): UserSettingDTO | undefined {
    return this.db
      .prepare(`SELECT * FROM user_settings WHERE id = ?`)
      .get(id) as UserSettingDTO;
  }
}


========================================================================
  FILE: src\dto\MinuteStatDTO.ts
========================================================================

export interface MinuteStatDTO {
  symbol: string;
  minute_start: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  ticks_count: number;
}


========================================================================
  FILE: src\dto\SignalDTO.ts
========================================================================

export interface SignalDTO {
  id?: number;
  user_id: number;
  symbol: string;
  direction: 'up' | 'down';
  percent: number;
  base_price: number;
  current_price: number;
  detected_at?: number;
  sent?: number;
}


========================================================================
  FILE: src\dto\TickerDTO.ts
========================================================================

export interface TickerDTO {
  symbol: string;
  price: number;
  event_ts: number; // unix seconds
}


========================================================================
  FILE: src\dto\UserDTO.ts
========================================================================

export interface UserDTO {
  id?: number;
  telegram_id: string;
  username?: string;
  created_at?: number;
}


========================================================================
  FILE: src\dto\UserSettingDTO.ts
========================================================================

export interface UserSettingDTO {
  id?: number;
  user_id: number;
  symbol: string;
  direction: 'up' | 'down';
  percent: number;
  interval_min: number; 
  enabled?: boolean;
  created_at?: number;
}


========================================================================
  FILE: src\services\BinanceSocketService.ts
========================================================================

/**
 * Сервис подключения к Binance WebSocket
 * Парсит !ticker@arr — массив тиков и вызывает колбек для каждого тика
 */
import WebSocket from 'ws';
import { config } from '../config';
import { logger } from '../utils/logger';
import { TickerDTO } from '../dto/TickerDTO';
import { StatsService } from './StatsService';

export class BinanceSocketService {
  private ws?: WebSocket;
  private url: string;

  constructor(private statsService: StatsService, url?: string) {
    this.url = url || config.BINANCE_WS_URL;
  }

  start() {
    this.ws = new WebSocket(this.url);

    this.ws.on('open', () => {
      logger.info('Connected to Binance WebSocket');
    });

    this.ws.on('message', (data) => {
      try {
        const parsed = JSON.parse(data.toString());
        if (Array.isArray(parsed)) {
          for (const t of parsed) {
            this.handleRawTicker(t);
          }
        } else if (parsed && parsed.s && parsed.c) {
          this.handleRawTicker(parsed);
        } else if (parsed.result === null && parsed.stream) {
          // ignore...
        } else if (parsed.stream && parsed.data) {
          this.handleRawTicker(parsed.data);
        }
      } catch (err) {
        logger.error({ err, data: data.toString() }, 'Failed to parse ws message');
      }
    });

    this.ws.on('close', (code) => {
      logger.warn({ code }, 'Binance WS closed — reconnect in 2s');
      setTimeout(() => this.start(), 2000);
    });

    this.ws.on('error', (err) => {
      logger.error({ err }, 'Binance WS error');
    });
  }

  private handleRawTicker(raw: any) {
    const symbol = raw.s || raw.symbol;
    const priceStr = raw.c || raw.price;
    if (!symbol || !priceStr) return;
    const price = Number(priceStr);
    const eventTs = Math.floor((raw.E ? raw.E : Date.now()) / 1000);
    const ticker: TickerDTO = {
      symbol,
      price,
      event_ts: eventTs,
    };
    this.statsService.onTicker(ticker);
  }

  stop() {
    if (this.ws) this.ws.close();
  }
}


========================================================================
  FILE: src\services\RateLimiterService.ts
========================================================================

/**
 * RateLimiterService предотвращает повторную отправку одинаковых сигналов одному пользователю чаще чем limitSec
 */
import { nowSec } from '../utils/helpers';

export class RateLimiterService {
  private lastSentMap: Map<string, number> = new Map(); // key -> unix sec

  constructor(private limitSec: number = 60) {}

  // key составляется как `${userId}:${symbol}:${direction}:${percent}`
  canSend(key: string): boolean {
    const last = this.lastSentMap.get(key);
    const now = nowSec();
    if (!last || now - last >= this.limitSec) {
      this.lastSentMap.set(key, now);
      return true;
    }
    return false;
  }
}


========================================================================
  FILE: src\services\SignalDetector.ts
========================================================================

import { UserSettingsRepository } from '../db/repositories/UserSettingsRepository';
import { SignalRepository } from '../db/repositories/SignalRepository';
import { StatsService } from './StatsService';
import { RateLimiterService } from './RateLimiterService';
import { SignalDTO } from '../dto/SignalDTO';
import { logger } from '../utils/logger';
import PQueue from 'p-queue';
import { config } from '../config';
import { percentChange } from '../utils/helpers';
import { TelegramBotService } from './TelegramBotService';
import { UserSettingDTO } from '../dto/UserSettingDTO';

export class SignalDetector {
  private settingsRepo = new UserSettingsRepository();
  private signalRepo = new SignalRepository();
  private queue = new PQueue({ concurrency: 2 });

  constructor(
    private statsService: StatsService,
    private rateLimiter: RateLimiterService,
    private telegramService: TelegramBotService,
    private checkIntervalSec: number = config.CHECK_INTERVAL_SEC
  ) {}

  start(): void {
    setInterval(() => this.checkAll(), this.checkIntervalSec * 1000);
  }

  async checkAll() {
    try {
      const active: UserSettingDTO[] = this.settingsRepo.listActive();
      for (const s of active) {
        const current = this.statsService.getCurrentPrice(s.symbol);
        const minutesAgo = s.interval_min  ?? 20;
        const base = this.statsService.getPriceMinutesAgo(s.symbol, minutesAgo);
        if (current == null || base == null) continue;

        const change = percentChange(base, current);
        const matched =
          (s.direction === 'up' && change >= s.percent) ||
          (s.direction === 'down' && change <= -s.percent);

        if (matched) {
          const key = `${s.user_id}:${s.symbol}:${s.direction}:${s.percent}`;
          if (!this.rateLimiter.canSend(key)) continue;

          const sig: SignalDTO = {
            user_id: s.user_id,
            symbol: s.symbol,
            direction: s.direction,
            percent: s.percent,
            base_price: base,
            current_price: current,
          };
          const saved: SignalDTO = this.signalRepo.create(sig);

          this.queue.add(async () => {
            try {
              await this.telegramService.sendSignal(saved);
              this.signalRepo.markSent(saved.id!);
            } catch (err) {
              logger.error({ err }, 'Failed to send signal');
            }
          });
        }
      }
    } catch (err) {
      logger.error({ err }, 'SignalDetector.checkAll error');
    }
  }
}


========================================================================
  FILE: src\services\StatsService.ts
========================================================================

/**
 * StatsService:
 * - Принимает тики
 * - Сохраняет их в ticks
 * - Агрегирует по минутам и сохраняет в minute_stats
 * - Держит последние цены в памяти для быстрого доступа
 */
import { TickerDTO } from '../dto/TickerDTO';
import { TickRepository } from '../db/repositories/TickRepository';
import { StatsRepository } from '../db/repositories/StatsRepository';
import { CoinRepository } from '../db/repositories/CoinRepository';
import { MinuteStatDTO } from '../dto/MinuteStatDTO';
import { logger } from '../utils/logger';
import { nowSec } from '../utils/helpers';

export class StatsService {
  private tickRepo = new TickRepository();
  private statsRepo = new StatsRepository();
  private coinRepo = new CoinRepository();

  // in-memory cache последних цен (symbol -> {price, ts})
  private lastPriceMap: Map<string, { price: number; ts: number }> = new Map();

  constructor() {}

  // Вызывается из BinanceSocketService
  onTicker(t: TickerDTO) {
    try {
      // Сохраняем raw tick
      this.tickRepo.insertTick(t.symbol, t.price, t.event_ts);

      // Обновляем coin таблицу (если новая монета)
      this.coinRepo.createIfNotExists(t.symbol);

      // Обновляем минутную агрегацию
      this.aggregateToMinute(t);

      // Обновляем in-memory последний тик
      this.lastPriceMap.set(t.symbol, { price: t.price, ts: t.event_ts });

      // Очистим старые тики (например, старше 24 часов)
      const olderThan = nowSec() - 24 * 60 * 60;
      this.tickRepo.deleteOlderThan(olderThan);
    } catch (err) {
      logger.error({ err }, 'StatsService.onTicker error');
    }
  }

  private aggregateToMinute(t: TickerDTO) {
    const minuteStart = Math.floor(t.event_ts / 60) * 60;

    // Используем публичный метод
    const exists = this.statsRepo.exists(t.symbol, minuteStart);

    if (!exists) {
      const stat: MinuteStatDTO = {
        symbol: t.symbol,
        minute_start: minuteStart,
        open: t.price,
        high: t.price,
        low: t.price,
        close: t.price,
        volume: 0,
        ticks_count: 1,
      };
      this.statsRepo.upsertMinuteStat(stat);
    } else {
      // Получаем частичную свечу
      const saved = this.statsRepo.getMinuteStat(t.symbol, minuteStart);
      if (!saved) return;

      const updated: MinuteStatDTO = {
        symbol: t.symbol,
        minute_start: minuteStart,
        open: saved.open ?? t.price,
        high: Math.max(saved.high ?? t.price, t.price),
        low: Math.min(saved.low ?? t.price, t.price),
        close: t.price,
        volume: (saved.volume ?? 0),
        ticks_count: (saved.ticks_count ?? 0) + 1,
      };
      this.statsRepo.upsertMinuteStat(updated);
    }
  }

  // Получить цену сейчас (в памяти или из БД)
  getCurrentPrice(symbol: string): number | null {
    const item = this.lastPriceMap.get(symbol);
    if (item) return item.price;
    const last = this.tickRepo.getLastTick(symbol);
    return last ? last.price : null;
  }

  // Получить цену ~20 минут назад (по минутной агрегации)
  getPriceMinutesAgo(symbol: string, minutesAgo: number): number | null {
    const target = Math.floor((nowSec() - minutesAgo * 60) / 60) * 60;

    // 1. Точная минута
    const exact = this.statsRepo.getCloseAt(symbol, target);
    if (exact !== undefined) return exact;

    // 2. Fallback: ближайшая минута назад
    const fallback = this.statsRepo.getLastCloseBefore(symbol, target);
    return fallback ?? null;
  }
}


========================================================================
  FILE: src\services\TelegramBotService.ts
========================================================================

/**
 * Сервис Telegram bot (Telegraf)
 * - Реализует команды /start, /add, /list, /remove, /toggle
 * - Отправляет сигналы пользователю (sendSignal)
 */
import { Telegraf } from 'telegraf';
import { config } from '../config';
import { UserRepository } from '../db/repositories/UserRepository';
import { UserSettingsRepository } from '../db/repositories/UserSettingsRepository';
import { logger } from '../utils/logger';
import { SignalDTO } from '../dto/SignalDTO';
import { UserSettingDTO } from '../dto/UserSettingDTO';

export class TelegramBotService {
  private bot: Telegraf;
  private userRepo = new UserRepository();
  private settingsRepo = new UserSettingsRepository();

  constructor(token?: string) {
    const tk = token || config.TELEGRAM_TOKEN;
    if (!tk) throw new Error('TELEGRAM_TOKEN is required');
    this.bot = new Telegraf(tk);
    this.setupHandlers();
  }

  setupHandlers() {
    // /start
    this.bot.start(async (ctx) => {
      const tgId = String(ctx.from?.id);
      const user = this.userRepo.findOrCreate(tgId, ctx.from?.username);
      await ctx.reply(`Привет, ${ctx.from?.username || 'пользователь'}! Я буду отслеживать ваши крипто-правила.`);
    });

    // /add SYMBOL direction percent
    // пример: /add BTCUSDT up 2
    this.bot.command('add', async (ctx) => {
      const text = ctx.message?.text || '';
      const parts = text.split(/\s+/);
      if (parts.length < 4 || parts.length > 5) {
        await ctx.reply(
          'Использование: /add SYMBOL up|down PERCENT [минуты]\n' +
          'Пример: /add BTCUSDT up 2\n' +
          '       /add DOGEUSDT up 10 5'
        );
        return;
      }

      const [, symbol, directionRaw, percentRaw, timeRaw] = parts;
      const direction = directionRaw.toLowerCase() === 'up' ? 'up' : 'down';
      const percent = Math.abs(Number(percentRaw));
      const timeWindow = timeRaw ? Math.max(1, Math.min(1440, Number(timeRaw))) : 20;

      if (!symbol || !percent || isNaN(percent)) {
        await ctx.reply('Неверные параметры');
        return;
      }

      const tgId = String(ctx.from?.id);
      const user = this.userRepo.findOrCreate(tgId, ctx.from?.username);
      const created = this.settingsRepo.add({
        user_id: user.id!,
        symbol: symbol.toUpperCase(),
        direction: direction as 'up' | 'down',
        percent,
        enabled: true,
        interval_min : timeWindow,
      } as any);

      if (created) {
        const timeText = timeWindow === 20 ? '' : ` за ${timeWindow} мин`;
        await ctx.reply(`Добавлено #${created.id}: ${created.symbol} ${created.direction} ${created.percent}%${timeText}`);
      } else {
        await ctx.reply('Правило не добавлено (дубликат)');
      }
    });

    // /list
    this.bot.command('list', async (ctx) => {
      const tgId = String(ctx.from?.id);
      const user = this.userRepo.findOrCreate(tgId, ctx.from?.username);
      const list = this.settingsRepo.listByUser(user.id as number); //TODO add check
      if (!list || list.length === 0) {
        await ctx.reply('У вас нет правил. Добавьте с помощью /add');
        return;
      }
      const msg = list
        .map((r: any) => `#${r.id} ${r.symbol} ${r.direction} ${r.percent}% ${r.enabled ? 'ON' : 'OFF'}`)
        .join('\n');
      await ctx.reply(`Ваши правила:\n${msg}`);
    });

    // /remove id
    this.bot.command('remove', async (ctx) => {
      const text = ctx.message?.text || '';
      const parts = text.split(/\s+/);
      if (parts.length < 2) {
        await ctx.reply('Использование: /remove <id>');
        return;
      }
      const id = Number(parts[1]);
      if (!id) {
        await ctx.reply('Неверный id');
        return;
      }
      this.settingsRepo.remove(id);
      await ctx.reply(`Правило #${id} удалено (если существовало).`);
    });

    // /toggle id
    this.bot.command('toggle', async (ctx) => {
      const text = ctx.message?.text || '';
      const parts = text.split(/\s+/);
      if (parts.length < 2) {
        await ctx.reply('Использование: /toggle <id>');
        return;
      }
      const id = Number(parts[1]);
      if (!id) {
        await ctx.reply('Неверный id');
        return;
      }
      this.settingsRepo.toggle(id);
      const updated = this.settingsRepo.getById(id) as UserSettingDTO; //TODO add check
      await ctx.reply(`#${id} теперь ${updated.enabled ? 'ON' : 'OFF'}`);
    });
  }

  // запускаем бота polling
  start() {
    this.bot.launch();
    logger.info('Telegram bot started');
    process.once('SIGINT', () => this.bot.stop('SIGINT'));
    process.once('SIGTERM', () => this.bot.stop('SIGTERM'));
  }

  // Отправка сигнала пользователю (используется SignalDetector)
  async sendSignal(signal: SignalDTO) {
    const user = this.userRepo.getById(signal.user_id);
    if (!user) return;

    const chatId = Number(user.telegram_id);
    const timeText = signal.detected_at
      ? new Date(signal.detected_at * 1000).toISOString().slice(11, 19)
      : '—';

    const text = `
  Сигнал: ${signal.symbol} ${signal.direction.toUpperCase()} ${signal.percent}%
  Базовая: ${signal.base_price.toFixed(8)}
  Текущая: ${signal.current_price.toFixed(8)}
  Время: ${timeText}
  `.trim();

    await this.bot.telegram.sendMessage(chatId, text);
  }
}


========================================================================
  FILE: src\types\index.d.ts
========================================================================

declare module '*.sql';


========================================================================
  FILE: src\utils\helpers.ts
========================================================================

/**
 * Утилиты
 */

/** Текущий unix timestamp (сек) */
export const nowSec = (): number => Math.floor(Date.now() / 1000);

/** Процент изменения (в процентах) */
export const percentChange = (from: number, to: number): number => {
  if (from === 0) return 0;
  return ((to - from) / from) * 100;
};


========================================================================
  FILE: src\utils\logger.ts
========================================================================

import pino from 'pino';

export const logger = pino({
  name: 'crypto-bot',
  level: process.env.LOG_LEVEL || 'info',
});


================================================================================
  KONETS FAYLOV
  Vsego obrabotano failov: 24
================================================================================
